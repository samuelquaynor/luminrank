import { Injectable, inject } from '@angular/core';
import { Observable, from, throwError, of } from 'rxjs';
import { map, catchError, switchMap } from 'rxjs/operators';
import { SupabaseClient } from '@supabase/supabase-js';
import { 
  League, 
  LeagueWithDetails, 
  CreateLeagueData, 
  UpdateLeagueData,
  LeagueSettings,
  ScoringSystem
} from '../models/league.model';

@Injectable({
  providedIn: 'root'
})
export class LeagueService {
  private supabase = inject(SupabaseClient);

  /**
   * Create a new league
   * Triggers auto-creation of settings and adds creator as member
   * Then updates settings with custom values if provided
   */
  createLeague(data: CreateLeagueData): Observable<League> {
    return from(
      this.supabase.auth.getUser()
    ).pipe(
      switchMap(({ data: { user }, error }) => {
        if (error || !user) {
          return throwError(() => new Error('User not authenticated'));
        }

        return from(
          this.supabase
            .from('leagues')
            .insert({
              name: data.name,
              description: data.description || null,
              game_type: data.gameType,
              is_private: data.isPrivate || false,
              created_by: user.id,
              invite_code: '' // Will be generated by trigger
            })
            .select()
            .single()
        ).pipe(
          switchMap(({ data: league, error: leagueError }) => {
            if (leagueError) throw leagueError;
            
            // If custom settings provided, update them
            if (data.settings) {
              return from(
                this.supabase
                  .from('league_settings')
                  .update({
                    scoring_system: data.settings.scoringSystem,
                    points_per_win: data.settings.pointsPerWin,
                    points_per_draw: data.settings.pointsPerDraw,
                    points_per_loss: data.settings.pointsPerLoss,
                    allow_draws: data.settings.allowDraws
                  })
                  .eq('league_id', league.id)
                  .select()
              ).pipe(
                map(() => league)
              );
            }
            
            return of(league);
          })
        );
      }),
      map((data) => {
        return this.mapLeagueFromDb(data);
      }),
      catchError(error => {
        console.error('Create league error:', error);
        return throwError(() => new Error(error.message || 'Failed to create league'));
      })
    );
  }

  /**
   * Get all leagues the current user is a member of
   */
  getMyLeagues(): Observable<League[]> {
    return from(
      this.supabase.auth.getUser()
    ).pipe(
      switchMap(({ data: { user }, error }) => {
        if (error || !user) {
          return throwError(() => new Error('User not authenticated'));
        }

        return from(
          this.supabase
            .from('leagues')
            .select(`
              *,
              league_members!inner(user_id)
            `)
            .eq('league_members.user_id', user.id)
            .eq('league_members.status', 'active')
            .order('created_at', { ascending: false })
        );
      }),
      map(({ data, error }) => {
        if (error) throw error;
        return data.map(league => this.mapLeagueFromDb(league));
      }),
      catchError(error => {
        console.error('Get my leagues error:', error);
        return throwError(() => new Error(error.message || 'Failed to fetch leagues'));
      })
    );
  }

  /**
   * Get a single league with settings and member count
   */
  getLeagueById(id: string): Observable<LeagueWithDetails> {
    return from(
      this.supabase
        .from('leagues')
        .select(`
          *,
          league_settings(*),
          league_members(count),
          creator:profiles!leagues_created_by_fkey(name)
        `)
        .eq('id', id)
        .single()
    ).pipe(
      map(({ data, error }) => {
        if (error) throw error;
        if (!data) throw new Error('League not found');
        
        const league = this.mapLeagueFromDb(data);
        const settings = data.league_settings && data.league_settings[0] 
          ? this.mapSettingsFromDb(data.league_settings[0])
          : {
              id: '',
              leagueId: id,
              scoringSystem: 'points' as ScoringSystem,
              pointsPerWin: 3,
              pointsPerDraw: 1,
              pointsPerLoss: 0,
              allowDraws: false,
              createdAt: new Date(),
              updatedAt: new Date()
            };
        const memberCount = data.league_members && data.league_members[0]?.count || 0;
        const creatorName = data.creator?.name || 'Unknown';

        return {
          ...league,
          settings,
          memberCount,
          creatorName
        };
      }),
      catchError(error => {
        console.error('Get league by id error:', error);
        return throwError(() => new Error(error.message || 'Failed to fetch league'));
      })
    );
  }

  /**
   * Update a league (creator only)
   */
  updateLeague(id: string, data: UpdateLeagueData): Observable<League> {
    const updateData: any = {};
    if (data.name !== undefined) updateData.name = data.name;
    if (data.description !== undefined) updateData.description = data.description;
    if (data.gameType !== undefined) updateData.game_type = data.gameType;
    if (data.isPrivate !== undefined) updateData.is_private = data.isPrivate;
    if (data.status !== undefined) updateData.status = data.status;
    updateData.updated_at = new Date().toISOString();

    return from(
      this.supabase
        .from('leagues')
        .update(updateData)
        .eq('id', id)
        .select()
        .single()
    ).pipe(
      map(({ data, error }) => {
        if (error) throw error;
        return this.mapLeagueFromDb(data);
      }),
      catchError(error => {
        console.error('Update league error:', error);
        return throwError(() => new Error(error.message || 'Failed to update league'));
      })
    );
  }

  /**
   * Delete a league (creator only)
   */
  deleteLeague(id: string): Observable<void> {
    return from(
      this.supabase
        .from('leagues')
        .delete()
        .eq('id', id)
    ).pipe(
      map(({ error }) => {
        if (error) throw error;
        return undefined;
      }),
      catchError(error => {
        console.error('Delete league error:', error);
        return throwError(() => new Error(error.message || 'Failed to delete league'));
      })
    );
  }

  /**
   * Join a league via invite code
   */
  joinLeagueByCode(code: string): Observable<League> {
    return from(
      this.supabase.auth.getUser()
    ).pipe(
      switchMap(({ data: { user }, error }) => {
        if (error || !user) {
          return throwError(() => new Error('User not authenticated'));
        }

        // First, find the league by invite code
        return from(
          this.supabase
            .from('leagues')
            .select('id')
            .eq('invite_code', code)
            .single()
        ).pipe(
          switchMap(({ data: leagueData, error: leagueError }) => {
            if (leagueError) throw new Error('Invalid invite code');
            
            // Add user as member
            return from(
              this.supabase
                .from('league_members')
                .insert({
                  league_id: leagueData.id,
                  user_id: user.id,
                  role: 'member'
                })
            ).pipe(
              switchMap(() => {
                // Return the league
                return from(
                  this.supabase
                    .from('leagues')
                    .select()
                    .eq('id', leagueData.id)
                    .single()
                );
              })
            );
          })
        );
      }),
      map(({ data, error }) => {
        if (error) throw error;
        return this.mapLeagueFromDb(data);
      }),
      catchError(error => {
        console.error('Join league error:', error);
        return throwError(() => new Error(error.message || 'Failed to join league'));
      })
    );
  }

  /**
   * Leave a league
   */
  leaveLeague(leagueId: string): Observable<void> {
    return from(
      this.supabase.auth.getUser()
    ).pipe(
      switchMap(({ data: { user }, error }) => {
        if (error || !user) {
          return throwError(() => new Error('User not authenticated'));
        }

        return from(
          this.supabase
            .from('league_members')
            .update({ status: 'left' })
            .eq('league_id', leagueId)
            .eq('user_id', user.id)
        );
      }),
      map(({ error }) => {
        if (error) throw error;
        return undefined;
      }),
      catchError(error => {
        console.error('Leave league error:', error);
        return throwError(() => new Error(error.message || 'Failed to leave league'));
      })
    );
  }

  /**
   * Map database league to domain model
   */
  private mapLeagueFromDb(data: any): League {
    return {
      id: data.id,
      name: data.name,
      description: data.description,
      createdBy: data.created_by,
      gameType: data.game_type,
      status: data.status,
      startDate: data.start_date ? new Date(data.start_date) : null,
      endDate: data.end_date ? new Date(data.end_date) : null,
      inviteCode: data.invite_code,
      isPrivate: data.is_private,
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at)
    };
  }

  /**
   * Map database settings to domain model
   */
  private mapSettingsFromDb(data: any): LeagueSettings {
    return {
      id: data.id,
      leagueId: data.league_id,
      scoringSystem: data.scoring_system,
      pointsPerWin: data.points_per_win,
      pointsPerDraw: data.points_per_draw,
      pointsPerLoss: data.points_per_loss,
      allowDraws: data.allow_draws,
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at)
    };
  }
}
